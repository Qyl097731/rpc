开发文档

# rpc-http

## 问题1

### 简述

在连接池的注册时候，通过List直接存不同的端点的connection，在随机取得时候并不能保证取到的connection包含
了将要调用的服务。

### 解决方案

### 时间线

2023/4/12-

## 问题1

### 简述

RpcClientHandler 中 send进行远程调用的时候，channel空指针

### 解决方案

发现 channelRegistered 时候注册的channel，在后续客户端invokeRemote的时候，new 了一个新的RpcClientHandler，导致最后没有触发channelRegistered
channel也就没有保存.

### 时间线

2023/4/12-2023/4/13

## 问题2

### 简述

性能差，单线程阻塞执行

如果是在同一个线程中执行，channelRead0返回前会一直阻塞；如果是在不同的线程中执行，channelWrite会把请求发送到发送缓冲区，然后立即返回，不会阻塞，而channelRead0在收到响应后才会返回。一般而言，Netty使用的是事件驱动模型，在一个线程中执行，因此channel.writeAndFlush()会一直阻塞到channelRead0返回。但是，如果你在代码中使用了异步IO或者采用了不同的事件驱动模型，那么这个问题的答案就会有所不同。

### 解决方案

异步执行

### 时间线

2023/4/12-

## 问题3

### 简述

客户端请求发出之后，服务器解码，始终报错空指针

### 解决方案

kryo反序列化的时候 readObjectOrNull 换成 readObject

### 时间线

2023/4/13 - 2023/4/13

## 问题4

### 简述

每次序列化和反序列化时都需要重新创建一个 Kryo 实例，这可能会带来一些性能上的问题。

### 解决方案

将 Kryo 实例作为一个单例对象，并通过对象池等机制来重复使用。

### 时间线

2023/4/13 - 2023/4/14

## 问题5

### 简述

server启动之后，对client开启Debug模式，会导致Kryo反序列化存在循环依赖时，会出现堆栈溢出（StackOverflow）的问题。

### 问题解决

在 debug 模式下，由于开启了很多优化选项，包括类加载、方法执行等等，可能会使反射行为与正常运行时的行为有所不同，因此可能会导致反射失败。其中最常见的问题就是由于JVM启用了类的懒加载或者JIT优化等机制，导致反射调用时还未被加载或优化的类或方法并不可见的问题。

一个例子是，因为Java动态编译器（JIT）在运行时通过对代码进行优化来提高执行速度。如果代码正在被动态编译，那么它的类可能会被临时解除锁定，从而难以在运行时用反射获得该类的数据和方法。

使用加入了一定插桩（如：ASM、AspectJ 等）的方法来实现反射，这样可以更加稳定地进行反射操作，并且不易受到JVM的影响而导致反射失败。
